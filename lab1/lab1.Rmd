---
title: "SOC-GA 2332 Intro to Stats Lab 1"
author: "Wenhao Jiang"
date: "9/8/2023"
output:
  html_document:
    df_print: paged
    theme: paper
    highlight: textmate
    toc: true
  pdf_document: 
    toc: true
---

<style type="text/css">

body{ 

    font-size: 16px;
    line-height: 1.7em;
    <!-- text-align: justify; -->

}

h1 { font-size: 32px; }

h2 { font-size: 24px; }

h3 { font-size: 20px; }

</style>

<br>

---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)

```

## Logistics & Announcements  

* My office hour: Tuesday 11:00 am - 12:20 pm RM 4131. You may sign up [here](https://www.wejoinin.com/sheets/vqcup), or directly email me to schedule a time if the above time does not work (wj2068@nyu.edu). 

* Plan of assignments (tentative):  

| Assignment |  Release   |     Due     |
|:----------:|:----------:|:-----------:|
|     1      | 09/11/2023 | 09/29/2023  |
|     2      | 10/02/2023 | 10/20/2023  |
|     3      | 10/23/2023 | 11/14/2023  |
|     4      | 11/15/2023 | 12/01/2023  |  


* Assignments will assist you
  * understand key concepts in statistics using simulations
  * familiarize yourself with codings in R
  * prepare for the final replication project

* Working in groups is strongly encouraged.
  
## Prerequisite
* Download & install R: https://cloud.r-project.org/
* Download & install RStudio: https://rstudio.com/products/rstudio/download/
* Sign up for Overleaf (for LaTeX): https://www.overleaf.com/ (Using your nyu email address will give you free access to professional account). 
  * We will use LaTeX for the final replication project. 
  * Overleaf is very easy to share and collaborate on projects (v.s. Microsoft Word).
  
## Part 1: Basics of RStudio and R Markdown

### What are R & RStudio  

  + **R** is a free programming language commonly used for statistical programming and graphics. Download & install: https://cloud.r-project.org/  

  + **RStudio** is an IDE (Integrated Development Environment) for R. It’s an application that enables you to write, run, and save your R code and programming outputs. Download & install: https://rstudio.com/products/rstudio/download/
  

### The layout of RStudio

<p align="center">
![Layout of Rstudio (Wickham & Grolemund 2017)](graph/rstudio-editor.png){width=50%}
</p> 

### Coding in R Script vs. R Markdown

  + **R Script** is a simple code script document. The output of R script cannot be saved within the script.
  
  + **R Markdown** is a simple formatting syntax for authoring HTML, PDF, and even Microsoft Word documents.
  
<p align="center">
![R Script (Left) and R Markdown (Right)](graph/rscript_vs_rmd.png){width=70%}
</p>
  
  + Different from R Script, **R Markdown** allows users to **present both their code and the code’s output (tables, plots, etc.) in a single document**, usually by "knitting"" (rendering) an R Markdown to a HTML or PDF file.  
  
  + R Markdown allows you to divide your code into sections, which helps you **better organize** your code.
  
  + R Markdown also allows you to type **mathematical equations** efficiently.
  
  + If you are **coding for assignments, R Markdown is preferred**. If you are coding for simpler tasks, you can use R script.
  

### R Markdown: Layout, the Markdown languages, and Knitting

+ In a R Markdown file, chunks with a *white* background are *text editor* chunks. You can incorporate formatted text (including mathematical equations) using the Markdown language. Use [this cheatsheet](https://rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf) for Markdown guidance.

+ Chunks with a *grey* background are *coding* chunks. You will code in these chunks.

+ You can run your code by line, or by chunk. The output (if any) will be displayed after the current coding chunk.  
+ You can knit (export/convert) a R Markdown file to HTML, PDF, or Word using the "Knit" button. 

<p align="center">
![R Markdown Layout](graph/lab1demo-rmd-all.png){width=70%}
</p> 


#### Additional tips: Typing equations in R Markdown

+ To type mathematical symbols and expressions, you need to follow a particular Markdown syntax. For example, to print the Greek letter $\alpha$, you need to type `$\alpha$` in the text editor chunk of your R Markdown file. But you don't need to memorize all of the expressions. Google or refer to [this guide](https://rpruim.github.io/s341/S19/from-class/MathinRmd.html) when you work on mathematical equations.

+ To insert equations, you need to wrap your expression with the dollar sign. To type "inline equations" (equations that won't break your lines), use the dollar sign `$` to wrap your expression: `$\hat{\mu} = \overline{y} = \frac{\sum_{i = 1}^{n}y_i}{n}$` gives: $\hat{\mu} = \overline{y} = \frac{\sum_{i = 1}^{n}y_i}{n}$.  

For "displayed equations" (equations that will break your lines), use the double dollar sign `$$` to wrap your expression: `$$\overline{y} = \displaystyle \frac{y_1 + y_2 + y_3 + ... + y_n}{n} = \displaystyle \frac{\sum_{i = 1}^{n} y_i}{n}$$` gives: $$\overline{y} = \displaystyle \frac{y_1 + y_2 + y_3 + ... + y_n}{n} = \displaystyle \frac{\sum_{i = 1}^{n} y_i}{n}$$ 

+ **Do not leave spaces between the `$$` (or `$`) and your mathematical notation!**

+ In R Markdown, hovering over your equation expressions will give you a preview of the equation you write.

#### Additional tips: Knitting R Markdown to HTML or PDF

+ As mentioned earlier, you can knit R Markdown files to HTML, PDF, or Word.

+ Before you knit, always make sure you can run your code from beginning to end. You won't be able to knit if some codes throw error messages. (We will talk about debugging later.) 

+ There are many options in R Markdown that helps you manipulate how you want to present your document. For example, you can hide the code chunk and only show the output by adding `echo = FALSE` in your code chunk options. You can also use `include = FALSE` to prevent the code AND its output to appear in your knitted document. You can also use `eval = FALSE` to prevent your code from running (but it will be displayed) in your knitted document. For detailed documentation of knitting options, read [here](https://yihui.org/knitr/options/).


---

## Part 2: Coding in R 

In this part, we will go through the basics of the R language, including installing packages, types of variable objects, types of data objects, and how to code a function in R. We will also come across plotting in R, but don't worry if you cannot understand the more complicated codes yet -we will cover them later. 

### 1. Installing and using packages (setting up your environment)  

+ Assume you are starting a new coding task, you should first open RStudio, create a coding file (either R script or R Markdown), and save the file to a path in your computer. (If you are starting a bigger project, such as an assignment or the final replication project, you should follow the bast-practice workflow [here](#best_practice) )

+ After creating a `.Rmd` or `.R` file, you need to install and load necessary packages (using `install.packages()` and `library()`) so that you can use functions from other statistical packages. 

+ You only need to install packages **once**. After they are installed, you can simply load them to your environment in the future using the `library()` function. 

+ For example, to use the packages `tidyverse`, `gridExtra`, and `kableExtra`, you need to type the following code in your coding chunk: `install.packages(c("tidyverse", "gridExtra", "kableExtra"))`, then use the `library()` function to load each of them in your environment.

```{r install and load packages}

# Install packages
# (after you install, you can delete the line below and keep only the 'library' line)
# install.packages(c("tidyverse", "gridExtra", "kableExtra"))

# Load package to environment
library(tidyverse)
library(gridExtra)
library(kableExtra)

```

### 2. Types of variables in R 

We use R to perform data cleaning and statistical analysis. But before that, we need to have a basic understanding about how to create, save, and retrieve unit of information in R. First, we will talk about **types of variables**. This is similar but not entirely the same as the types of variables we discussed in class (categorical vs numeric). In R, types of variables is relevant because R processes different variable types differently.

+ Most common data types in R: 
  (i) **Logical** variable: `TRUE` (`T`) or `FALSE` (`F`)  
  (ii) **Character** variable (think of the "nominal categorical variables" we covered in lecture): a string, e.g. "hello world!", "college education", "female"  
  (iii) **Numeric** variable: 
    + **Integer** (think of the "discrete variables" we covered in lecture): e.g. 1L, 2L, ...
    + **Double** (think of the "continuous variables" we covered in lecture): e.g. 1.44, 3.14
    + R automatically converts between these two classes when needed for mathematical purposes.

+ Variable types matter when you use different functions in R. For example, you cannot perform arithmetic with character variables even if they appear to be numbers. 

+ Check variable type using `class()` or `str()`

+ To create a variable, you give it a name first, then use either `<-` or `=` followed by the value you want to assign. E.g. `variable1 = "hello world!"`

+ It's preferable to **leave spaces around your `<-` or `=`** so that your code is easy to read. 

```{r variable types, eval = FALSE}

# Run the following codes in your environment:

# logical
TRUE
FALSE
str(T)
str(TRUE)
class(T)
class(TRUE)

# character
c1 = "1.1"
c2 = "2"

# numeric
n1 = 1.1
n2 = 2

# try run:
c1 + c2 # this will throw an error message
n1 + n2

# check variable type
str(c1)
str(n1)

class(c1)
class(n1)

# you can also use is.xxx() to get a T/F for a particular data type:
is.numeric(c1)
is.numeric(n1)

is.character(c1)
is.character(n1)

is.integer(c1)
is.integer(n1)

```

### 3. Types of data in R

Here, data are defined as a collection of variables. 

+ Most common data types in R:  

  (i) **Vectors**: A collection of elements of the same data type, e.g. logical vector, character vector, numeric vector.

  (ii) **Matrices**: A vector with two dimensions. Elements in a matrix must share the same variable type (numeric, character, etc.).
  
  (iii) **Arrays**: Arrays are similar to matrices but can have more than two dimensions.
  
  (iv) **Data frames**: Similar to matrices but different columns can have different variables types (numeric, character, logical, etc.). There can also be columns that have *data structure* rather than *variables*, e.g. a column of lists, a column of data frames, a column of matrices, etc.  
  
  (v) **Lists**: An ordered collection of objects with no constraint on their variable or data types, e.g. a list of character, a list of numeric, a list of vector, a list of list, a list of a mix of logical variables, character variables, and dataframes.
  
  (vi) **Factors**: A vector that is *ordered* (think of the "ordinal categorical variables" we covered in lecture). It can organize a categorical variable in a particular order for your desired ranking/ordering needs. For example, you can change a vector of educational levels `c("high school graduate", "4-year college", "some college", "below high school", "graduate or above")` to have an internal ranking `"below high school" < "high school graduate" < "some college" < "4-year college" < "graduate or above"` so that when you plot, these categories are ordered. 
  
  
+ Similar to variable types, data types matter when you use different functions in R. It also matters in terms of indexing and managing data.

+ Similar to variable, to create a data object, you give it a name first, then use either `<-` or `=` followed by the data object you want to assign, e.g. `vector1 = c(1, 2, 5.3, 6, -2, 4)`.

+ It's preferable to **leave space after each comma `", "`** in your code to make it easy to read.

```{r data types,  eval = FALSE}

# Run the following codes in your environment:

# --------- Vector --------- 
v1 = c(1, 2, 5.3, 6, -2, 4) # numeric vector
v2 = c("one", "two", "three") # character vector
v3 = c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE) #logical vector

v4 = vector(mode = "numeric", length = 10) # a vector of zeros
v4[5] = 8 # you can assign value by indexing the vector

v5 = seq(0.1, 1, 0.1) # seq() creates a regular sequence 

# check if vector 
is.vector(v1)

# check length of vector
length(v1)

# vector operation
v6 = v4 + v5


# --------- Matrices --------- 
m1 = matrix(rep(1, 9), nrow = 3, ncol = 3)
m2 = matrix(seq(0.1, 1.5, 0.1), nrow = 3, ncol = 5)
# combine matrices
cbind(m1, m2)
# scalar
0.5 * m1
# transpose
t(m2)
# diagonal elements
diag(m2)
# matrix multiplication
m1 %*% m2
# element-wise multiplication
m1 * m2[1:3, 1:3]



# --------- Data frames --------- 
var1 <- c(1, 2, 3, 4)
var2 <- c("red", "white", "red", NA)
var3 <- c(TRUE, TRUE, TRUE, FALSE)
mydf <- data.frame(var1, var2, var3)
names(mydf) <- c("ID", "Color", "Passed") # update variable names

# Base R methods of data frame indexing 
mydf[1:2] # columns 1, 2 of data frame
mydf[c(1, 3), ] # row 1, 3 of data frame
mydf[c("ID", "Color")] # columns ID and Color from data frame
mydf$Color # variable Color in the data frame

# Convert a vector or matrix to df
as.data.frame(v1)
as.data.frame(m1)


# --------- Lists --------- 
l1 = list(n1, c1, v1, m1)
l1
# List index
l1[4]
l1[[4]]
l1[4][[1]]
# Nested list
l2 = list(m2, l1)
l2

```


```{r data types-factor,  eval = TRUE}

# --------- Factor --------- 

# A vector of education levels, unordered
edu <- c(rep("high school graduate", 15), 
         rep("4-year college", 4),
         rep("graduate or above", 2),
         rep("some college", 6),
         rep("below high school", 6))

# Plot its count: Default order is alphabetical
edu %>%
  as.data.frame() %>%
  ggplot(aes(x = edu)) + 
  geom_bar()

# Covert vector to a factor with cutomized levels
edu_factor <- factor(edu, 
                     levels = c("below high school", 
                                "high school graduate" , 
                                "some college", 
                                "4-year college",
                                "graduate or above"))
# Plot the counts again:
edu_factor %>%
  as.data.frame() %>%
  ggplot(aes(x = edu_factor)) + 
  geom_bar()

```


### 4. What's a function

+ Functions execute certain tasks. For example, the function `class(x)` is a function that tells you the type of your input variable or data object. Similarly, the function `library(lib_name)` is a function that loads a library you specified in the parenthesis to your environment. 

+ A function is consist of a name, a set of arguments (input), and an output. The function `class(x)` has the function name `class`, and the input `x`, and will return an output -a character tells you the type of `x`. The function `library(lib_name)` has the function name `library`, the input `lib_name`, and will return an output in the form of loading the package to your environment. 

+ You can always learn about the structure of a function using the "Help" tab in RStudio. You can also call the function documentation by typing `?` followed by the function name in the Console panel in RStudio. For example you can try type `?class` in the Console panel -what do you see?

+ You can write your own functions in R using the function syntax below:

```
your_function_name <- function(input){
  
  # A series of actions or operations of your function
  code
  code
  code
  
  return(output)
  
}

```

+ For example, write a function that add 1 to each value of an vector:

```{r function,  eval = FALSE}

# function
add_one <- function(vector){
  out_vector = vector + 1
  return(out_vector)
}

# try:
add_one(v1)

```

### Part 2 Exercise

1. The table below shows the results of a survey question using a five-point Likert scale. Create a **factor** variable corresponding to the distribution of the survey result, and replicate the plot shown below.


|  Answer   | n   |
|:---------|-----:|
|Strongly agree|  10|
|Agree      |  23|
|Neutral    |  30|
|Disagree   |  18|
|Strongly disagree|  12|


<p align="left">
![](graph/part2_exercise.png){width=50%}
</p> 

```{r part2 q1}

# Write your code here

```

2. In R, you can check the remainder of a division using the `%%` operator. For example, the remainder of $4 \div 2$ can be calculated by `4 %% 2` in R.  

  (i) Write a function (call it `even_remainder`) such that with an input numeric vector, it will return a numeric vector indicating the remainder value when each number in the vector is divided by 2. For example, with the input `v_in = c(1, 2, 3, 4)`, the function will return `1 0 1 0`.  
  
  (ii) (Bonus Question) Write a function (call it `if_even`) such that with an input numeric vector, it will return a *logical* vector indicating whether the respective value is an even number. For example, with the input `v_in = c(1, 2, 3, 4)`, the function will return `FALSE TRUE FALSE TRUE`.

```{r part2 q2}

# Write your code here

```

---

### Additional Tips for Using R

#### Debugging in R coding

+ If you come across an error message, debug your code by:

  (i) Reading documentation of the function/package you use: Type the package or function name you use in the **Help** tab in the lower right panel.
  
  (ii) Googling your error massage.
  
  (iii) Posting your question on [stack overflow](https://stackoverflow.com/). Make sure to provide a reproducible example for the bug you run into. Here's [a guide on how to make a minimal reproducible example](https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example).

+ For more information, you can read [this chapter](https://adv-r.hadley.nz/debugging.html) on debugging in R.


<a id="best_practice"></a>  

#### Workflow for more complicated coding projects: The best practice step-by-step guide  

  - Every time when you start a new project or assignment, starting by creating a new, devoted folder for that project. (A even better way to save and track your work is to use GitHub repositories -Google it if you are interested. We might also cover it in lab if we have time.)
  - Second, open **Rstudio**, click **File**, then select **New Project...**, and then choose the project folder you created in step 1, name the project and save it.
  - Third, open that **.Rproj** file you just created, and start coding.
  - After you are done coding and want to exit Rstudio, remember to **save** your current coding progress so that when you open the **.Rproj** file again, you start exactly from where you stopped. 
  
<p align="center">
![Save your session data before you exit Rstudio](graph/rstudio-save.png){width=50%}
</p>
  
  - To better manage your files, I recommend that you create **subfolders** within the project folder to organize your files, for example, a folder called **data** to save data files, a folder called **graphs** to save plots, images, etc.


#### Other advice

+ Managing your working environment:

  (i) Keep an eye on objects in your environment. It's always easier to keep track of your work if you clear your environment every time you start a new task. In addition, by removing large data objects in your environment, R will run more smoothly.
  
  (ii) But make sure you **save the important objects before you clear your environment**. I always create a `temp_data` folder for temporary data, and use `save(object_name, file = "temp_data/object_name.RData")` to quickly save things I might need to use in the future by using `load("temp_data/object_name.RData")`.
  
  (iii) To clean the working environment, I often change the environment display from `List` to `Grid`, and select the objects I want to remove, then use the little broom logo in the Environment tab. You can also use `rm(list=ls())` to clear everything in your work space, but use this with caution!
  
  
+ In-line comments and other coding style suggestions:

  (i) Make sure you comment your code (start comments with the `#` sign) **as detailed as you can**. It will help your grader, your reader, and your(future)self to understand what's going on in the code.
  
  (ii) In general, it's better to be generous in spacing. Add spaces between numbers, =, commas, etc. You can start a new line after each comma (`,`) in your code, it's often possible to **break a very long line of code to multiple lines**.
  
  (iii) R language is **case-sensitive**. Make sure you are using the correct function name, for example, `as.Date()` instead of `as.date()`.
  

+ Recommended reading: [R for Data Science](https://r4ds.had.co.nz/index.html)


---


## Part 3: LaTeX and Overleaf

### What is LaTeX

+ LaTeX is a typesetting language for creating documents, including manuscripts and presentations.

+ It provides typesetting syntax that allows user to quickly tackle complicated typesetting tasks, such as inputting equations, cross-referencing, creating tables and bibliographies.  

+ You don't have to learn coding LaTeX from scratch. There are a wide variety of templates ready to use on Overleaf.
        
### What is Overleaf

+ Overleaf is a collaborative cloud-based **LaTeX editor**.  

+ You can check out a demo document on Overleaf [here](https://www.overleaf.com/project/601c205a62003571959e317a).

+ Overleaf offers comprehensive guidance on how to create and edit LaTeX documents.  

+ My suggestion for you to use \LaTeX{} for the final project is to start from **a default template in Overleaf** ( [check out their templates here](https://www.overleaf.com/latex/templates) ). Then you can search and learn the specifics when you come across questions or problems --such as how to insert tables, how to fit tables to page, insert equations, how to change the font size, how to organize citations, etc.  

+ However, if you want to learn the basics and try creating a \LaTeX{} document from scratch, you can [use the 30-minute quick guide](https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes) on Overleaf.


## Part 4 Tidy Data and Tidyverse

### Working with Data: The Standard Workflow (Wickham & Grolemund 2017)

A typical data science project starts with data cleaning ("tidying"). In practice, we spend a LOT of time just to clean the data so that it is ready for descriptive analysis and modeling exercise. For example, dealing with missing values, incoherent variable codings across survey years, outliers, inflations, etc. You can read more about using R for data science [here](https://r4ds.had.co.nz/explore-intro.html).

<p align="center">
![](graph/data-science-workflow.png){width=70%}
</p> 

### Tidy Data

+ Before doing analysis to your data, look carefully at your dataframe, and ask: **Is this a "tidy" data set?**  

+ In a tidy data set:  
  (i) Each unit of observation is saved in its own row.
  (ii) Each variable is saved in its own column.
  (iii) Each value must have its own cell.

<p align="center">
![](graph/tidy-data.png){width=70%}
</p> 

+ Look at the following three dataframes. Which are tidy? Which are not? Why?

  (i) Dataframe A
  
<p align="center">
![](graph/tidy-data-df3.png){width=55%}
</p>
  
  (ii) Dataframe B
  
<p align="center">
![](graph/tidy-data-df2.png){width=70%}
</p> 
  
   (iii) Dataframe C

<p align="center">
![](graph/tidy-data-df1.png){width=50%}
</p> 


+ Tidy data is a foundation for data transformation in R using the `tidyverse` package collection. For data cleaning, we use a lot of functions from the `dplyr` package. For plotting, we often use the `ggplot2` package. By loading `tidyverse` to your environment, you will have all these packages loaded. 

<p align="center">
![](graph/tidyverse-scrnshot.png){width=70%}
</p>


+ To learn `tidyverse` and coding in R more systematically, I strongly recommend the free online book by Wickham & Grolemund (2017): [R for Data Science](https://r4ds.had.co.nz/index.html). (A lot of the examples used in this lab is drawn from the book.)


## Part 5 Using Tidyverse for Data Wrangling

### 1. Import Comma-separated files

+ Comma-separated files (.csv) are the most common data files.

+ Here I use the built-in function `read.csv()` to load .csv data files. Since I use `Rproject`, I only need to type in the *relative* file path instead of the absolute file path. 

+ If you are not using `.Rproj`, you can input the *absolute* file path of your data files. You can also install and load the `here` package to find your absolute file path (google the package to learn more).


```{r import csv}

# Load csv files
gapminder <- read.csv("data/gapminder.csv") 
tidy_df1 <- read.csv("data/tidy_example_1.csv")
tidy_df2 <- read.csv("data/tidy_example_2.csv")


```

### 2. Browse data in R

+ You can click the little table logo next to your data object in the `Enviornment` panel to view data, or type `View(data_object)` in the R Console. 

+ Common things to check about your data: 
  + Sample size, i.e. number of observations: `nrow(data_object)`
  + Number of varibles: `ncol(data_object)`, and names of variables: `names(data_object)`
  + Summary statistics of each variable: `summary(data_object)`
  
+ You can also view the first and last several rows of your data: `head(data_object)`, `tail(data_object)`

```{r browse data, eval = F}

# View data in a pop-up window
View(gapminder)

# Summary statistics by variable
summary(gapminder)

# variable names
names(gapminder)

# number of rows and columnes
nrow(gapminder)
ncol(gapminder)

# Check first several observations
head(gapminder, n = 10)

# Check last several observations
tail(gapminder, n = 5)

```

### 3. Basic `tidyverse` command

+ We are going to use functions from the `dplyr` package under the `tidyverse` package collection.

+ Let's start with the following basic commands for manipulating data frame:
 (i) Pick observations by their values `filter()`
 (ii) Reorder the rows `arrange()`
 (iii) Select/index observations `slice()`
 (iv) Pick variables by their names `select()`
 (v) Rename variables by `rename()`
 (vi) Create new variables with functions of existing variables `mutate()`

```{r filter-1, eval = F}
# ---------- Filter ---------- 
# Filter only Asian countries:
filter(gapminder, continent == "Asia")

# Or: Filter observations whose continent equals either Asia or Americas
filter(gapminder, continent == "Asia" | continent == "Americas")

# Or: Instead of using | , you can use %in% followed by a value vector 
filter(gapminder, continent %in% c("Asia", "Americas"))

# And: Filter observations that satisfy both conditions
filter(gapminder, continent == "Asia" & year == 2007)

# Negation: not equal to
filter(gapminder, continent != "Asia")

# Negation: filter values that's not equal to any value included in the vector
filter(gapminder, !(continent %in% c("Asia", "Americas")))

# Combine AND and Negation:
filter(gapminder, continent == "Asia" & year != 2007)

# Filter only 2007 data:
filter(gapminder, year == 2007)
```

```{r filter-2}
# Save data as a new data object
gapminder_2007 <- filter(gapminder, year == 2007)
```

```{r arrange, eval = F}
# ---------- Arrange ---------- 
# Arrange() helps you sort observations
# Sort by GDP per capita, from lowest to highest
arrange(gapminder_2007, gdpPercap)

# Sort by GDP per capita, from highest to lowest
# Use the desc() function to your variable to sort in descending order
arrange(gapminder_2007, desc(gdpPercap))
```

```{r slice, eval = F}
# ---------- Slice ---------- 
# Select the 2nd row of the data
slice(gapminder, 2)

# Select 2nd to 10th row of the data
slice(gapminder, 2:10)
```

```{r select, eval = F}
# ---------- Select ---------- 
# Select desired variables by name
select(gapminder, country, pop)

# You can deselect using - before column name
select(gapminder, -country, -pop)

# Select all columns between country and year (inclusive)
select(gapminder, country:year)

```

```{r rename, eval = F}
# ---------- Rename ---------- 
rename(gapminder, population = pop)

```

```{r mutate, eval = F}
# ---------- Mutate ---------- 
# Create new variables using "mutate"
mutate(gapminder, 
       gdpPercap_in_thousand = gdpPercap/1000,
       gdp = pop * gdpPercap,
       log_gdp = log(gdp), # natural log
       log2_gdp = log2(gdp),
       id = row_number())  # create id by row number

```

### 4. "Pipe" in `tidyverse` coding

+ For the benefit of writing and reading codes, there is a special syntax in tidyverse called "piping." 

+ The general idea is that you start from a dataframe, or an object, and use the pipe `%>%` command to lay out the actions you want to take to that object. 

+ For example, if you want to first arrange the GDP per Capita in descending order, and then keep the top 5 countries, you can pipe these two actions:

```{r piping-1}
gapminder_2007 %>% 
  arrange(desc(gdpPercap)) %>% 
  slice(1:5)

```

+ You can also do the above use one single function, which can also be piped to your data object

```{r piping-2, eval = F}

gapminder_2007 %>% top_n(5, wt = gdpPercap)

```

+ Piping make your code looks cleaner and is more efficient because you don't need to save objects created in the middle steps. 

+ For example, we can skip the step to create `gapminder_2007` by piping the `filter` step to the `gapminder` data:

```{r piping-3, eval = F}
gapminder %>% 
  filter(year == 2007) %>%
  arrange(desc(gdpPercap)) %>%
  slice(1:5)
```

+ Piping also makes plotting easier, which we will cover later.

### 5. Make untidy data tidy

+ As we covered in the lecture, before analyzing data, make sure it's **tidy**.

+ What if it's not tidy?  
  (i) There are two `pivot` functions in `tidyverse` that help you make untidy data tidy. 
  (ii) The general idea is to shift column names to become values of a variable, or the other way round.
  (iii) `pivot_longer()` helps you to bring the information in the column names to being values in a single column.
  (iv) `pivot_wider()` does the opposite
  (v) There are other packages and functions that help you do these. For example, you can look into the `melt()` and `dcast()` functions in the `data.table` package [here](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html). (The `data.table` package is a parallel data wrangling package with `dplyr`, and is generally faster than `tidyverse` when you deal with large datasets. But the syntax is less intuitive than `dplyr`. We may cover how to use `data.table` in a futuer session if you are interested.)

+ Remeber what count as tidy **depends on your questions**, specifically, what count as **an observation** in your study. 

```{r tidy-1, eval = F}

# Observe the data structure of the two untidy examples
# If in our study, a unit of observation is a country's stats in a particular year
# What changes are needed in order to make them tidy?
View(tidy_df1)
View(tidy_df2)


# For df1, we need to first bring years from column names to a variable
# then put values of "cases" and "population" in two columns

tidy_df1 %>%
  
  # bring years from column names to a variable
  pivot_longer(cols = c(year_1999, year_2000), 
               names_to = "year", 
               values_to = "count") %>%
  
  # remove "year_" prefix in the year variable
  mutate(year = str_remove(year, "year_")) %>% 
  
  # put values of "cases" and "population" in two columns
  pivot_wider(names_from = type, 
              values_from = count)


# For df2, we need "cases" and "population" to have their own columns
tidy_df2 %>%
  pivot_wider(names_from = type, 
              values_from = count)



# You can save clean df as a new object, 
tidy_clean <- tidy_df2 %>%
  pivot_wider(names_from = type, 
              values_from = count)


# And export as .csv to your data folder
write.csv(tidy_clean, "data/tidy_clean.csv", row.names = F)


# You can manipulate your table layout in HTML 
# using kable_styling() from the kableExtra package:
tidy_clean %>%
  kbl() %>%
  kable_styling()
```

### 6. Summarise and group data

+ The `summarise()` function collapses many values down to a single summary, e.g. mean, median, standard deviation, max, min, etc.

+ The `group_by()` function creates a grouped copy of a table, thus you can apply various functions to each group.

+ Combining `group_by()` with `summarise()`, you can get various **descriptve statistics** for your data, either for the entire dataset, or by group (e.g. groups by gender, race, education level, etc.). 
```{r summarise and group, eval = F}

# Example for summarise()
gapminder %>%
  filter(year == 2007) %>%
  summarise(avg_life = mean(lifeExp))


# Example for combining group_by() and summarise()
gapminder %>%
  filter(year == 2007) %>%
  group_by(continent) %>%
  summarise(avg_life = mean(lifeExp))


# You can get many different summary statistics for each group using summarise()
summary1 <- gapminder %>%
  filter(year == 2007) %>%
  group_by(continent) %>%
  summarise(year = 2007,
            n_country = n(),
            max_gdpPercap = max(gdpPercap), 
            min_gdpPercap = min(gdpPercap), 
            mean_gdpPercap = mean(gdpPercap),
            sd_gdpPercap = sd(gdpPercap))


summary1
```


