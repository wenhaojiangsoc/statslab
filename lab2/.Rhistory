colour = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Distribution of the Sample Mean",
subtitle = paste("Size of each sample =", sample_size, "Number of samples =", reptition))
return(hist)
}
# Plot (You can play with function parameter values to see how they change the output)
set.seed(1008)
p1 <- plot_sampling_mean(reptition = 1000, sample_size = 3, pop_binom, 0.01)
# set seed to ensure your code is reproducible
set.seed(11011)
# generate a random number that follows a Bernoulli distribution with p = 0.5
# then covert the vector to a data frame
pop_binom <- rbinom(n = 100000, size = 1, 0.5) %>% as_tibble()
# plot the population
pop_binom %>%
ggplot(aes(value)) +
geom_histogram(color = "black", fill = "grey") +
labs(title = "Histogram of Simulated Population with Bernoulli Distribution",
subtitle = "N = 100000, p = 0.5",
x = "")
plot_sampling_mean <- function(reptition, sample_size, pop_df, hist_binwidth){
sample_mean <- vector(mode = "numeric", length = reptition)
for (i in 1:reptition){
sample <- pop_df %>% sample_n(size = sample_size, replace = FALSE)
sample_mean[i] <- mean(sample$value)
}
hist <- sample_mean %>%
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(binwidth = hist_binwidth, fill = "grey", color = "black") +
geom_vline(aes(xintercept = mean(sample_mean)), color = "red", linetype = "dashed") +
geom_text(aes(mean(sample_mean) + 10*hist_binwidth,
label = paste("mean =", round(mean(sample_mean), 4)),
y = -0.2),
colour = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Distribution of the Sample Mean",
subtitle = paste("Size of each sample =", sample_size, "Number of samples =", reptition))
return(hist)
}
# Plot (You can play with function parameter values to see how they change the output)
set.seed(1008)
p1 <- plot_sampling_mean(reptition = 1000, sample_size = 3, pop_binom, 0.01)
p2 <- plot_sampling_mean(reptition = 1000, sample_size = 5, pop_binom, 0.01)
p3 <- plot_sampling_mean(reptition = 1000, sample_size = 30, pop_binom, 0.01)
p4 <- plot_sampling_mean(reptition = 1000, sample_size = 100, pop_binom, 0.01)
grid.arrange(p1, p2, p3, p4, ncol = 1)
grid.arrange(p1, p2, p3, p4, ncol = 1, heights=c(1, 1, 1, 1))
grid.arrange(p1, p2, p3, p4, ncol = 1, heights=c(2, 2, 2, 2))
grid.arrange(p1, p2, p3, p4, ncol = 2)
grid.arrange(p1, p2, p3, p4, ncol = 2)
View(pop_binom)
# First create four df of random samples
set.seed(11011)
sample10 <- pop_binom %>%
sample_n(size = 10, replace = FALSE) %>%
mutate(sample_size = 10)
sample100 <- pop_binom %>%
sample_n(size = 100, replace = FALSE) %>%
mutate(sample_size = 100)
sample1000 <- pop_binom %>%
sample_n(size = 1000, replace = FALSE) %>%
mutate(sample_size = 1000)
sample10000 <- pop_binom %>%
sample_n(size = 10000, replace = FALSE) %>%
mutate(sample_size = 10000)
# Combine df, recode variables
sample_df <- rbind(sample10, sample100, sample1000, sample10000)
# Plot
sample_df %>%
ggplot(aes(x = value, fill = as.factor(value))) +
geom_bar(stat = "count", width = 0.5) +
facet_wrap(~sample_size, scales = "free") +
labs(title = "Sample Distribution for Different Sample Size")
# Plot
sample_df %>%
mutate(value = ifelse(value == 1, yes = "1", no = "0")) %>%
ggplot(aes(x = value, fill = value)) +
geom_bar(stat = "count", width = 0.5) +
facet_wrap(~sample_size, scales = "free") +
labs(title = "Sample Distribution for Different Sample Size")
plot_sampling_mean <- function(reptition, sample_size, pop_df, hist_binwidth){
sample_mean <- vector(mode = "numeric", length = reptition)
for (i in 1:reptition){
sample <- pop_df %>% sample_n(size = sample_size, replace = FALSE)
sample_mean[i] <- mean(sample$value)
}
hist <- sample_mean %>%
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(binwidth = hist_binwidth, fill = "grey", color = "black") +
geom_vline(aes(xintercept = mean(sample_mean)), color = "red", linetype = "dashed") +
geom_text(aes(mean(sample_mean) + 10*hist_binwidth,
label = paste("mean =", round(mean(sample_mean), 4)),
y = -0.2),
colour = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Dist of Sample Mean",
subtitle = paste("Sample size =", sample_size, "; Reptition =", reptition))
return(hist)
}
# Plot (You can play with function parameter values to see how they change the output)
set.seed(1008)
p1 <- plot_sampling_mean(reptition = 1000, sample_size = 3, pop_binom, 0.01)
grid.arrange(p1, p2, p3, p4, ncol = 2)
set.seed(1008)
p1 <- plot_sampling_mean(reptition = 1000, sample_size = 3, pop_binom, 0.01)
p2 <- plot_sampling_mean(reptition = 1000, sample_size = 5, pop_binom, 0.01)
p3 <- plot_sampling_mean(reptition = 1000, sample_size = 30, pop_binom, 0.01)
p4 <- plot_sampling_mean(reptition = 1000, sample_size = 100, pop_binom, 0.01)
grid.arrange(p1, p2, p3, p4, ncol = 2)
grid.arrange(p1, p2, p3, p4, ncol = 2, main = "Sampling Dist of Sample Mean")
grid.arrange(p1, p2, p3, p4, ncol = 2)
knitr::opts_chunk$set(echo = TRUE)
# Load package to environment
library(tidyverse)
library(gridExtra)
library(kableExtra)
# Load csv files
gapminder <- read.csv("data/gapminder.csv")
# List sample size & sample mean
sample_df %>%
group_by(sample_size) %>%
summarise(sample_mean = mean(value)) %>%
mutate(diff_true_mean = 0.5 - sample_mean)
# List sample size & sample mean
sample_df %>%
group_by(sample_size) %>%
summarise(sample_mean = mean(value)) %>%
mutate(diff_true_mean = 0.5 - sample_mean) %>%
kbl(align = "c") %>%
kable_styling()
knitr::opts_chunk$set(echo = TRUE)
# Load package to environment
library(tidyverse)
library(gridExtra)
library(kableExtra)
# Load csv files
gapminder <- read.csv("data/gapminder.csv")
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram()
# You can adjust the binwidth and other features of the histogram
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram(binwidth = 2000, fill = "grey", color = "black")
# Instead of frequency (count) you can use percentage on the Y axis, and overlay a density curve
# Notice we have different aesthetic mappings for geom_histograme and geom_density
gapminder %>%
ggplot() +
geom_histogram(
aes(x = gdpPercap, y = ..density..),
binwidth = 2000,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = gdpPercap),
color = "red"
)
# You can do log transform directly when plotting
gapminder %>%
ggplot() +
geom_histogram(
aes(x = log(gdpPercap), y = ..density..),
binwidth = 0.1,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = log(gdpPercap)),
color = "red"
)
knitr::opts_chunk$set(echo = TRUE)
# Load package to environment
library(tidyverse)
library(gridExtra)
library(kableExtra)
# Load csv files
gapminder <- read.csv("data/gapminder.csv")
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram()
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram(binwidth = 2000, fill = "grey", color = "black")
# You can adjust the binwidth and other features of the histogram
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram(binwidth = 2000, fill = "grey", color = "black") +
theme_classic()
gapminder %>%
ggplot() +
geom_histogram(
aes(x = gdpPercap, y = ..density..),
binwidth = 2000,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = gdpPercap),
color = "red"
)
gapminder %>%
ggplot() +
geom_density(
aes(x = gdpPercap),
color = "red"
)
gapminder %>%
ggplot() +
geom_histogram(
aes(x = log(gdpPercap), y = ..density..),
binwidth = 0.1,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = log(gdpPercap)),
color = "red"
)
# You can adjust the binwidth and other features of the histogram
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram(binwidth = 2000, fill = "grey", color = "black")
# You can do log transform directly when plotting
gapminder %>%
ggplot() +
geom_histogram(
aes(x = log(gdpPercap), y = ..density..),
binwidth = 0.1,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = log(gdpPercap)),
color = "red"
)
gapminder %>%
filter(lifeExp <= 60) %>%
ggplot(aes(x = year)) +
geom_bar()
gapminder %>%
filter(lifeExp <= 60) %>%
ggplot(aes(x = year, fill = continent)) +
geom_bar()
gapminder %>%
filter(lifeExp <= 60) %>%
ggplot(aes(x = year, fill = continent)) +
geom_bar(position = "fill")
gapminder %>%
filter(lifeExp <= 60) %>%
ggplot(aes(x = year, fill = continent)) +
geom_bar(position = "dodge")
gapminder %>%
filter(lifeExp <= 60) %>%
ggplot() +
geom_bar(aes(x = year, fill = continent), position = "fill")
# Scatter plot:
# Relationship between GDP per Capita and life expectancy
gapminder %>%
ggplot(aes(x = gdpPercap, y = lifeExp)) +
geom_point()
gapminder %>%
ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +
geom_point(alpha = 0.7, size = 1.5)
# Let's see how the scatter plot of log(GDP per Capital) and life expectancy
gapminder %>%
ggplot(aes(x = log(gdpPercap), y = lifeExp, color = continent)) +
geom_point(alpha = 0.7, size = 1.5)
gapminder %>%
filter(continent == "Americas") %>%
ggplot(aes(x = gdpPercap)) +
geom_boxplot()
gapminder %>%
ggplot(aes(x = continent, y = gdpPercap)) +
geom_boxplot(outlier.colour = "hotpink", outlier.shape = 1)
gapminder %>%
filter(country == "Sweden") %>%
ggplot(aes(x = year, y = gdpPercap)) +
geom_point() +
geom_line()
gapminder %>%
filter(country %in% c("India", "Russia", "Brazil", "China")) %>%
ggplot(aes(x = year, y = gdpPercap, color = country)) +
geom_point() +
geom_line()
gapminder %>%
ggplot(aes(x = gdpPercap, y = lifeExp)) +
geom_point(shape = 1, alpha = 0.5) +
geom_smooth(method = "lm")
gapminder %>%
ggplot(aes(x = gdpPercap, y = lifeExp)) +
geom_point(shape = 1, alpha = 0.5) +
geom_smooth(method = "loess")
gapminder %>%
ggplot(aes(x = log(gdpPercap), y = lifeExp)) +
geom_point(shape = 1, alpha = 0.5) +
geom_smooth(method = "lm")
gapminder %>%
ggplot(aes(x = log(gdpPercap), y = lifeExp)) +
geom_point(shape = 1, alpha = 0.5) +
geom_smooth(method = "loess")
# Let's add titles and optimize plot layout for the BRIC country GDP plot
gapminder %>%
filter(country %in% c("India", "Russia", "Brazil", "China")) %>%
ggplot(aes(x = year, y = gdpPercap, color = country)) +
geom_point() +
geom_line() +
labs(title = "GDP per capita in Brail, China, and India (1952 to 2007)",
x = NULL,
y = "GDP per capita",
color = "Country") +
theme_minimal() +
scale_color_grey() +
scale_x_continuous(breaks = unique(gapminder$year)) +
theme(axis.text.x = element_text(size = 8, angle = 40, vjust = 0.6))
# To save: ggsave("graph/gdp_bric.png") # input absolute file path if you are not using Rproject
ggsave("graph/gdp_bric.png")
# Let's add titles and optimize plot layout for the BRIC country GDP plot
gapminder %>%
filter(country %in% c("India", "Russia", "Brazil", "China")) %>%
ggplot(aes(x = year, y = gdpPercap, color = country)) +
geom_point() +
geom_line() +
labs(title = "GDP per capita in Brail, China, and India (1952 to 2007)",
x = NULL,
y = "GDP per capita",
color = "Country") +
#theme_minimal() +
scale_color_grey() +
scale_x_continuous(breaks = unique(gapminder$year)) +
theme(axis.text.x = element_text(size = 8, angle = 40, vjust = 0.6))
ggsave("graph/gdp_bric.png")
knitr::opts_chunk$set(echo = TRUE)
summary1 <- gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarise(year = 2007,
n_country = n(),
max_gdpPercap = max(gdpPercap),
min_gdpPercap = min(gdpPercap),
mean_gdpPercap = mean(gdpPercap),
sd_gdpPercap = sd(gdpPercap))
summary1
# set a seed to ensure your code is reproducible
# the seed number can be any number, and you should always run this line
# together with the code that involves generation of random numbers
set.seed(11011)
# generate a random number that follows a Bernoulli distribution with p = 0.5
# then covert the vector to a data frame
pop_binom <- rbinom(n = 100000, size = 1, 0.5)
# set a seed to ensure your code is reproducible
# the seed number can be any number, and you should always run this line
# together with the code that involves generation of random numbers
set.seed(11011)
# generate a random number that follows a Bernoulli distribution with p = 0.5
# then covert the vector to a data frame
pop_binom <- rbinom(n = 100000, size = 1, 0.5)
hist(pop_binom)
pop_binom %>%
# Convert vector to a tidy dataframe
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(color = "black", fill = "grey") +
labs(title = "Histogram of Simulated Population with Bernoulli Distribution",
subtitle = "N = 100000, p = 0.5",
x = "")
hist(pop_binom)
set.seed(11011)
sample10 <- pop_binom %>%
# Sample from pop
sample(size = 10, replace = FALSE) %>%
# Convert to tidy data object
as_tibble() %>%
# Add a new variable called "sample_size" that equals to the sample size
mutate(sample_size = 10)
View(sample10)
set.seed(11011)
sample10 <- pop_binom %>%
# Sample from pop
sample(size = 10, replace = FALSE) %>%
# Convert to tidy data object
as_tibble() %>%
# Add a new variable called "sample_size" that equals to the sample size
mutate(sample_size = 10)
sample100 <- pop_binom %>%
sample(size = 100, replace = FALSE) %>%
as_tibble() %>%
mutate(sample_size = 100)
sample1000 <- pop_binom %>%
sample(size = 1000, replace = FALSE) %>%
as_tibble() %>%
mutate(sample_size = 1000)
sample10000 <- pop_binom %>%
sample(size = 10000, replace = FALSE) %>%
as_tibble() %>%
mutate(sample_size = 10000)
sample_df <- rbind(sample10, sample100, sample1000, sample10000)
View(sample_df)
# Plot
sample_df %>%
# Covert numeric variable to character variable (b/c we only have two possible outcomes)
mutate(value = ifelse(value == 1, yes = "1", no = "0")) %>%
ggplot(aes(x = value, fill = value)) +
geom_bar(stat = "count", width = 0.5) +
facet_wrap(~sample_size, scales = "free") +
labs(title = "Sample Distribution for Different Sample Size")
# List sample size & sample mean
sample_df %>%
group_by(sample_size) %>%
summarise(sample_mean = mean(value)) %>%
mutate(diff_to_true_mean = 0.5 - sample_mean) %>%
kbl(align = "c") %>%
kable_styling()
View(sample_df)
set.seed(10010)
for (i in 1:100){
# Inside the for-loop, you first randomly sample 50 rows from the pop
sample <- sample(pop_binom, size = 50, replace = FALSE)
# Calculat the mean and save it as the i-th number in the vector
mean_container[i] <- mean(sample)
}
# We create a "container" object to save the result
# It can be a vector, a matrix, a list, etc. as long as it fits your purpose
mean_container <- vector(mode = "numeric", length = 100)
set.seed(10010)
for (i in 1:100){
# Inside the for-loop, you first randomly sample 50 rows from the pop
sample <- sample(pop_binom, size = 50, replace = FALSE)
# Calculat the mean and save it as the i-th number in the vector
mean_container[i] <- mean(sample)
}
head(mean_container, n = 10)
mean_container %>%
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(binwidth = 0.01, fill = "grey", color = "black") +
geom_vline(aes(xintercept = sd_neg), color = "red") +
geom_vline(aes(xintercept = mean), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = sd_pos), color = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Distribution of the Sample Mean (100 iterations of sample n = 50)",
subtitle = "Mean marked by the dashed line, 1 standard deviation around the mean marked by solid lines")
# Mean and SD of the sampling distribution
mean = mean(mean_container)
sd_pos = mean + sd(mean_container)
sd_neg = mean - sd(mean_container)
# Plot
mean_container %>%
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(binwidth = 0.01, fill = "grey", color = "black") +
geom_vline(aes(xintercept = sd_neg), color = "red") +
geom_vline(aes(xintercept = mean), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = sd_pos), color = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Distribution of the Sample Mean (100 iterations of sample n = 50)",
subtitle = "Mean marked by the dashed line, 1 standard deviation around the mean marked by solid lines")
# Build the function
plot_sampling_mean <- function(reptition, sample_size, pop_vec, hist_binwidth){
sample_mean <- vector(mode = "numeric", length = reptition)
for (i in 1:reptition){
sample <- sample(pop_vec, size = sample_size, replace = FALSE)
sample_mean[i] <- mean(sample)
}
hist <- sample_mean %>%
as_tibble() %>%
ggplot(aes(value)) +
geom_histogram(binwidth = hist_binwidth, fill = "grey", color = "black") +
geom_vline(aes(xintercept = mean(sample_mean)), color = "red", linetype = "dashed") +
geom_text(aes(mean(sample_mean) + 10*hist_binwidth,
label = paste("mean =", round(mean(sample_mean), 4)),
y = -0.2),
colour = "red") +
scale_x_continuous(limits=c(0, 1)) +
labs(title = "Sampling Dist of Sample Mean",
subtitle = paste("Sample size =", sample_size, "; Reptition =", reptition))
return(hist)
}
# Plot (You can play with function parameter values to see how they change the output)
set.seed(1008)
p1 <- plot_sampling_mean(reptition = 1000, sample_size = 3, pop_binom, 0.01)
p2 <- plot_sampling_mean(reptition = 1000, sample_size = 5, pop_binom, 0.01)
p3 <- plot_sampling_mean(reptition = 1000, sample_size = 30, pop_binom, 0.01)
p4 <- plot_sampling_mean(reptition = 1000, sample_size = 100, pop_binom, 0.01)
grid.arrange(p1, p2, p3, p4, ncol = 2)
knitr::opts_chunk$set(echo = TRUE)
# Load package to environment
library(tidyverse)
library(gridExtra)
library(kableExtra)
# Load csv files
gapminder <- read.csv("data/gapminder.csv")
gapminder %>%
ggplot(aes(x = gdpPercap)) +
geom_histogram()
# Instead of frequency (count) you can use percentage on the Y axis, and overlay a density curve
# Notice we have different aesthetic mappings for geom_histogram and geom_density
gapminder %>%
ggplot() +
geom_histogram(
aes(x = gdpPercap),
binwidth = 2000,
fill = "grey",
color = "black"
) +
geom_density(
aes(x = gdpPercap),
color = "red"
)
